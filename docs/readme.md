# Разработка игры от А до Я на Unity
В данной статье, хочу познакомить читателя с своим процессом разработки игр на Unity. Оговорюсь сразу, что подход у меня нестандартный и является плодом продолжительного наступания на грабли. 

Чем подход отличается от того, что вы можете встретить в большинстве статей и официальной документации?
1. Мы почти не будем использовать `MonoBehaviour` (родительский класс для любый кастомных компонентов для игровых объектов)
2. Мы будем писать код в проекте Visual C#, а не Unity (далее подробнее)
3. Мы будем хранить исходники в папку `/src`, а не в `Assets` проекта юнити
4. Будем писать nunit-тесты и запускать их из редактора (я использую Rider)
5. Полностью разделим данные от представления

## Внимание к данным
На примерно четвертом году своей практики с Unity (примерно пару лет назад), я четко осознал, что корень 99% проблем возникающих в ходе разработки связаны с одним или более пунктом из списка выше:
- Представление (объект сцены, элемент интерфейса) жестко связан с моделью данных
- Проблемы разделения состояния системы (игра\меню\пауза и тд)
- Косячность транспорта данных: сложность получения, отсутствие или несвоевременная реакция на изменения

Одним словом, **все** проблемы (и всегда) имели корни в организации слоя данных. Конечно, у меня возникали трудности с оптимизацией, реализацией каких-нибудь визуальных эффектов и в других аспектах разработки, но это были трудности и через них можно было пройти ~~c потом и кровью~~ восполнив знания из самых разных источников. 

Проблемы же требовали костылей и\или рефакторинга. 

Поэтому, я сейчас с максимальным уважением отношусь в вопросу организации данных в системе. Для организации данных и реагирования на их изменения, в ходе разработки игры в рамках статьи, я буду использовать архитектурный фреймворк — Rentitas.

Rentitas — это реализация Entity-Component-System паттерна основанная на форке Entitas. Ключевая особенность Rentitas и Entitas в том, что по соглашению в них запрещено добавление какой-либо логики в компоненты и объекты (entity).

Rentitas предоставляет удобные механизмы для написания реактивной логики — кода выполняющегося исключительно при изменении определенных компонентов. 

## Подготовка проекта
Мы заранее разделим проект на части: код, контент, проекты Unity, зависимости. Данное решение позволит:
- Создать легковесный(ые) репозиторий для кода 
- Синхронизировать с облочным хранилищем контент
- Создать необходимое количество проектов юнити (под целевые платформы) без необходимости дублирования кода и контента в каждый из них
- Обновлять зависимости путем получения актуальных коммитов из соответствующих репозиториев.

Структура папки проекта проста: 
```batch
%PROJECT_ROOT%  :: корневая папка проекта
  /builds       :: билды проекта
  /docs         :: документация к проекты (в моем случае данная статья)
  /projects     :: проекты юнити
  /src          :: исходники проекта
  /content      :: контент проекта (графические ассеты, музыка и т.д.)
  /third        :: зависимости
```

### Проект Visual C#
Проект с кодом создаем в папке `%PROJECT_ROOT%/src`. Так как это наш ключевой проект назовем его именем игры — Shapetris. Я создаю проект в IDE Rider, но отличий от Visual Studio почти нету. 

1. Edit > New > Empty Project > Shapetris
2. Пока не добавили зависимости, меняем фреймворк на 3.5: Shapetris (проект, а не решение) > Properties > Target Framework Version: 3.5

В проекте Shapetris будет наш основной код игры, в проектах масштабнее, я разделяю код на модули и их API. Но тут нам это не нужно.

Кроме проекта Shapetris нам нужны: Shapetris.Editor и Shapetris.Tests. Добавляем в решение и не забываем выставить правильный фреймворк.

#### Зависимости
Для разработки нам потребуются библиотеки:
- Фреймворка (.net 3.5):
  - System
  - System.Data
- Сторонние
  - Rentitas
  - UnityEngine
  - UnityEditor
  - NUnit

Добавить UnityEngine.dll и UnityEditor.dll (к Shapetris.Editor) к проектам можно из директории: `%UNITY_INSTALL_ROOT%/Editor/Data/Managed`. NUnit добавляем от туда же: nunit.framework.dll (он уже скомпилирован под 3.5).

С Rentitas же сложнее. Варианта два: исходники или скомпилированные dll. Выбирать вам в первом случае вы сможете быстро посмотреть внутренности фреймфорка, но пожертвуете производительностью IDE и скоростью сборки. 

#### Rentitas как .dll
Мы можете скачать заранее подготовленные .dll файлы по [ссылке](https://github.com/alerdenisov/Rentitas/releases/latest) или скомпилировать их самостоятельно из исходников: склонируйте [репозиторий]https://github.com/alerdenisov/Rentitas) в папку `%PROJECT_ROOT%/third`: 
```
git clone https://github.com/alerdenisov/Rentitas.git
```

Откройте в IDE и скомпилируйте Release версию. 

Добавьте папку `Rentitas.dll`, `Rentitas.Unity.dll` во все проекты.

#### Rentitas как исходники
Через контекстное меню решения `Shapetris` создайте подпапку `Rentitas` (Add > Solution Folder). Правым кликом по папки и добавляем два проекта (Add exisiting project): `%PROJECT_ROOT\third\Rentitas\Rentitas\Rentitas.csproj` и `%PROJECT_ROOT\third\Rentitas\Rentitas.Unity\Rentitas.Unity.csproj`

## Разработка модели данных
Первичная подготовка завершена! Добро пожаловать во вторую часть статьи: [разработку модели данных](game-state.md).